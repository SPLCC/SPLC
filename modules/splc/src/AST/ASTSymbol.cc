#include "AST/ASTSymbol.hh"
#include "Core/Utils/ControlSequence.hh"

namespace splc {

namespace internal {

using utils::logging::ControlSeq;

// clang-format off
/// Automatically generated by GNU Bison
#ifdef YY_NULLPTR
#undef YY_NULLPTR
#endif
#define YY_NULLPTR nullptr

// YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
// First, the terminals, then, starting at \a YYNTOKENS, nonterminals.
const char*
const yytname_[] =
{
"\"end of file\"", "error", "\"invalid token\"", "KwdAuto", "KwdExtern",
"KwdRegister", "KwdStatic", "KwdTypedef", "KwdConst", "KwdRestrict",
"KwdVolatile", "KwdInline", "VoidTy", "IntTy", "SignedTy", "UnsignedTy",
"LongTy", "FloatTy", "DoubleTy", "CharTy", "KwdEnum", "KwdStruct",
"KwdUnion", "KwdIf", "KwdElse", "KwdSwitch", "KwdWhile", "KwdFor",
"KwdDo", "KwdDefault", "KwdCase", "KwdGoto", "KwdContinue", "KwdBreak",
"KwdReturn", "ID", "TypedefID", "OpAssign", "OpMulAssign", "OpDivAssign",
"OpModAssign", "OpPlusAssign", "OpMinusAssign", "OpLShiftAssign",
"OpRShiftAssign", "OpBAndAssign", "OpBXorAssign", "OpBOrAssign", "OpAnd",
"OpOr", "OpNot", "OpLT", "OpLE", "OpGT", "OpGE", "OpNE", "OpEQ",
"OpQMark", "OpColon", "OpLShift", "OpRShift", "OpBAnd", "OpBOr",
"OpBNot", "OpBXor", "OpDPlus", "OpDMinus", "OpPlus", "OpMinus",
"OpAstrk", "OpDiv", "OpMod", "OpDot", "OpRArrow", "OpSizeOf", "OpLSB",
"OpRSB", "OpComma", "OpEllipsis", "PSemi", "PLC", "PRC", "PLP", "PRP",
"UIntLiteral", "SIntLiteral", "FloatLiteral", "CharLiteral", "StrUnit",
"SubscriptExpr", "CallExpr", "AccessExpr", "ExplicitCastExpr",
"AddrOfExpr", "DerefExpr", "SizeOfExpr", "KwdThen", "DecltrPrec",
"FuncDeclPrec", "OpUnaryPrec", "PLParen", "PRParen", "PLSBracket",
"PRSBracket", "$accept", "ParseRoot", "$@1", "TransUnit",
"ExternDeclList", "ExternDecl", "DeclSpec", "StorageSpec",
"SpecQualList", "TypeSpec", "FuncSpec", "TypeQual", "TypeName",
"BuiltinTypeSpec", "AbsDecltr", "DirAbsDecltr", "StructOrUnionSpec",
"StructOrUnion", "StructDeclBody", "StructDeclList", "StructDecl",
"StructDecltrList", "StructDecltr", "EnumSpec", "EnumBody",
"EnumeratorList", "Enumerator", "EnumConst", "Decltr", "DirDecltr",
"WrappedDirDecltr", "PtrDecl", "TypeQualList", "Decl", "DirDecl",
"InitDecltrList", "InitDecltr", "Initializer", "InitializerList",
"Designation", "DesignatorList", "Designator", "FuncDef", "FuncDecl",
"FuncDecltr", "DirFuncDecltr", "DirDecltrForFunc", "ParamTypeList",
"ParamList", "ParamDecl", "CompStmt", "GeneralStmtList", "Stmt",
"ExprStmt", "SelStmt", "LabeledStmt", "JumpStmt", "IterStmt",
"ForLoopBody", "ConstExpr", "Constant", "PrimaryExpr", "PostfixExpr",
"MemberAcessOp", "UnaryExpr", "UnaryArithOp", "CastExpr", "MulExpr",
"MulOp", "DivOp", "AddExpr", "AddOp", "ShiftExpr", "ShiftOp", "RelExpr",
"RelOp", "EqualityExpr", "EqualityOp", "OpBAndExpr", "OpBXorExpr",
"OpBOrExpr", "LogicalOpAndExpr", "LogicalOpOrExpr", "CondExpr",
"AssignExpr", "AssignOp", "Expr", "InitExpr", "ArgList", "StringLiteral",
"IDWrapper", YY_NULLPTR
};
// clang-format on

std::string_view getSymbolName(ASTSymbolType symbol) noexcept
{
    return {yytname_[static_cast<int>(symbol)]};
}

std::ostream &printSymbolConsoleTraits(std::ostream &os,
                                       SPLSymbolType symbol) noexcept
{
    switch (symbol) {
    case SPLSymbolType::YYNTOKENS:
    case SPLSymbolType::YYEMPTY:
    case SPLSymbolType::YYEOF:
    case SPLSymbolType::YYerror:
    case SPLSymbolType::YYUNDEF: {
        os << ControlSeq::Bold << ControlSeq::Red;
        break;
    }
    case SPLSymbolType::KwdAuto:
    case SPLSymbolType::KwdExtern:
    case SPLSymbolType::KwdRegister:
    case SPLSymbolType::KwdStatic:
    case SPLSymbolType::KwdTypedef:
    case SPLSymbolType::KwdConst:
    case SPLSymbolType::KwdRestrict:
    case SPLSymbolType::KwdVolatile:
    case SPLSymbolType::KwdInline:
    case SPLSymbolType::VoidTy:
    case SPLSymbolType::IntTy:
    case SPLSymbolType::SignedTy:
    case SPLSymbolType::UnsignedTy:
    case SPLSymbolType::LongTy:
    case SPLSymbolType::FloatTy:
    case SPLSymbolType::DoubleTy:
    case SPLSymbolType::CharTy: {
        os << ControlSeq::Bold << ControlSeq::Blue;
        break;
    }
    case SPLSymbolType::KwdEnum:
    case SPLSymbolType::KwdStruct:
    case SPLSymbolType::KwdUnion:
    case SPLSymbolType::KwdIf:
    case SPLSymbolType::KwdElse:
    case SPLSymbolType::KwdSwitch:
    case SPLSymbolType::KwdWhile:
    case SPLSymbolType::KwdFor:
    case SPLSymbolType::KwdDo:
    case SPLSymbolType::KwdDefault:
    case SPLSymbolType::KwdCase:
    case SPLSymbolType::KwdGoto:
    case SPLSymbolType::KwdContinue:
    case SPLSymbolType::KwdBreak:
    case SPLSymbolType::KwdReturn: {
        os << ControlSeq::Bold << ControlSeq::Magenta;
        break;
    }
    case SPLSymbolType::ID:
    case SPLSymbolType::TypedefID: {
        os << ControlSeq::Bold << ControlSeq::BrightBlue;
        break;
    }
    case SPLSymbolType::OpAssign:
    case SPLSymbolType::OpMulAssign:
    case SPLSymbolType::OpDivAssign:
    case SPLSymbolType::OpModAssign:
    case SPLSymbolType::OpPlusAssign:
    case SPLSymbolType::OpMinusAssign:
    case SPLSymbolType::OpLShiftAssign:
    case SPLSymbolType::OpRShiftAssign:
    case SPLSymbolType::OpBAndAssign:
    case SPLSymbolType::OpBXorAssign:
    case SPLSymbolType::OpBOrAssign:
    case SPLSymbolType::OpAnd:
    case SPLSymbolType::OpOr:
    case SPLSymbolType::OpNot:
    case SPLSymbolType::OpLT:
    case SPLSymbolType::OpLE:
    case SPLSymbolType::OpGT:
    case SPLSymbolType::OpGE:
    case SPLSymbolType::OpNE:
    case SPLSymbolType::OpEQ:
    case SPLSymbolType::OpQMark:
    case SPLSymbolType::OpColon:
    case SPLSymbolType::OpLShift:
    case SPLSymbolType::OpRShift:
    case SPLSymbolType::OpBAnd:
    case SPLSymbolType::OpBOr:
    case SPLSymbolType::OpBNot:
    case SPLSymbolType::OpBXor:
    case SPLSymbolType::OpDPlus:
    case SPLSymbolType::OpDMinus:
    case SPLSymbolType::OpPlus:
    case SPLSymbolType::OpMinus:
    case SPLSymbolType::OpAstrk:
    case SPLSymbolType::OpDiv:
    case SPLSymbolType::OpMod:
    case SPLSymbolType::OpDot:
    case SPLSymbolType::OpRArrow:
    case SPLSymbolType::OpSizeOf:
    case SPLSymbolType::OpLSB:
    case SPLSymbolType::OpRSB:
    case SPLSymbolType::OpComma:
    case SPLSymbolType::OpEllipsis: {
        break;
    }
    case SPLSymbolType::PSemi:
    case SPLSymbolType::PLC:
    case SPLSymbolType::PRC:
    case SPLSymbolType::PLP:
    case SPLSymbolType::PRP: {
        os << ControlSeq::Green;
        break;
    }
    case SPLSymbolType::UIntLiteral:
    case SPLSymbolType::SIntLiteral:
    case SPLSymbolType::FloatLiteral: {
        os << ControlSeq::Bold << ControlSeq::Green;
        break;
    }
    case SPLSymbolType::CharLiteral:
    case SPLSymbolType::StrUnit: {
        os << ControlSeq::Yellow;
        break;
    }
    case SPLSymbolType::SubscriptExpr:
    case SPLSymbolType::CallExpr:
    case SPLSymbolType::AccessExpr:
    case SPLSymbolType::ExplicitCastExpr:
    case SPLSymbolType::AddrOfExpr:
    case SPLSymbolType::DerefExpr:
    case SPLSymbolType::SizeOfExpr: {
        os << ControlSeq::Bold << ControlSeq::BrightMagenta;
        break;
    }
    case SPLSymbolType::KwdThen:
    case SPLSymbolType::DecltrPrec:
    case SPLSymbolType::FuncDeclPrec:
    case SPLSymbolType::OpUnaryPrec:
    case SPLSymbolType::PLParen:
    case SPLSymbolType::PRParen:
    case SPLSymbolType::PLSBracket:
    case SPLSymbolType::PRSBracket:
    case SPLSymbolType::ParseRoot:
    case SPLSymbolType::TransUnit:
    case SPLSymbolType::ExternDeclList:
    case SPLSymbolType::ExternDecl:
    case SPLSymbolType::DeclSpec:
    case SPLSymbolType::StorageSpec:
    case SPLSymbolType::SpecQualList:
    case SPLSymbolType::TypeSpec:
    case SPLSymbolType::FuncSpec:
    case SPLSymbolType::TypeQual:
    case SPLSymbolType::TypeName:
    case SPLSymbolType::BuiltinTypeSpec:
    case SPLSymbolType::AbsDecltr:
    case SPLSymbolType::DirAbsDecltr:
    case SPLSymbolType::StructOrUnionSpec:
    case SPLSymbolType::StructOrUnion:
    case SPLSymbolType::StructDeclBody:
    case SPLSymbolType::StructDeclList:
    case SPLSymbolType::StructDecl:
    case SPLSymbolType::StructDecltrList:
    case SPLSymbolType::StructDecltr:
    case SPLSymbolType::EnumSpec:
    case SPLSymbolType::EnumBody:
    case SPLSymbolType::EnumeratorList:
    case SPLSymbolType::Enumerator:
    case SPLSymbolType::EnumConst:
    case SPLSymbolType::Decltr:
    case SPLSymbolType::DirDecltr:
    case SPLSymbolType::WrappedDirDecltr:
    case SPLSymbolType::PtrDecl:
    case SPLSymbolType::TypeQualList:
    case SPLSymbolType::Decl:
    case SPLSymbolType::DirDecl:
    case SPLSymbolType::InitDecltrList:
    case SPLSymbolType::InitDecltr:
    case SPLSymbolType::Initializer:
    case SPLSymbolType::InitializerList:
    case SPLSymbolType::Designation:
    case SPLSymbolType::DesignatorList:
    case SPLSymbolType::Designator:
    case SPLSymbolType::FuncDef:
    case SPLSymbolType::FuncDecl:
    case SPLSymbolType::FuncDecltr:
    case SPLSymbolType::DirFuncDecltr:
    case SPLSymbolType::DirDecltrForFunc:
    case SPLSymbolType::ParamTypeList:
    case SPLSymbolType::ParamList:
    case SPLSymbolType::ParamDecl: {
        os << ControlSeq::Bold << ControlSeq::Green;
        break;
    }
    case SPLSymbolType::CompStmt:
    case SPLSymbolType::GeneralStmtList:
    case SPLSymbolType::Stmt:
    case SPLSymbolType::ExprStmt:
    case SPLSymbolType::SelStmt:
    case SPLSymbolType::LabeledStmt:
    case SPLSymbolType::JumpStmt:
    case SPLSymbolType::IterStmt: {
        os << ControlSeq::Bold << ControlSeq::BrightMagenta;
        break;
    }
    case SPLSymbolType::ForLoopBody:
    case SPLSymbolType::ConstExpr:
    case SPLSymbolType::Constant:
    case SPLSymbolType::PrimaryExpr:
    case SPLSymbolType::PostfixExpr:
    case SPLSymbolType::MemberAcessOp:
    case SPLSymbolType::UnaryExpr:
    case SPLSymbolType::UnaryArithOp:
    case SPLSymbolType::CastExpr:
    case SPLSymbolType::MulExpr:
    case SPLSymbolType::MulOp:
    case SPLSymbolType::DivOp:
    case SPLSymbolType::AddExpr:
    case SPLSymbolType::AddOp:
    case SPLSymbolType::ShiftExpr:
    case SPLSymbolType::ShiftOp:
    case SPLSymbolType::RelExpr:
    case SPLSymbolType::RelOp:
    case SPLSymbolType::EqualityExpr:
    case SPLSymbolType::EqualityOp:
    case SPLSymbolType::OpBAndExpr:
    case SPLSymbolType::OpBXorExpr:
    case SPLSymbolType::OpBOrExpr:
    case SPLSymbolType::LogicalOpAndExpr:
    case SPLSymbolType::LogicalOpOrExpr:
    case SPLSymbolType::CondExpr:
    case SPLSymbolType::AssignExpr:
    case SPLSymbolType::AssignOp:
    case SPLSymbolType::Expr:
    case SPLSymbolType::InitExpr:
    case SPLSymbolType::ArgList: {
        os << ControlSeq::Bold << ControlSeq::Green;
        break;
    }
    case SPLSymbolType::StringLiteral:
    case SPLSymbolType::IDWrapper: {
        os << ControlSeq::Bold << ControlSeq::Yellow;
        break;
    }
    }
    return os;
}

std::ostream &operator<<(std::ostream &os, ASTSymbolType sym) noexcept
{
    return os << getSymbolName(sym);
}

} // namespace internal

} // namespace splc